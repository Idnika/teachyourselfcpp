20191106



p.273

A stream is a logical device that either produces or consumes information.

When a C++ program begins, these four streams are automatically opened:

cin		Standard input			Keyboard
cout		Standard output		Screen
cerr		Standard error			Screen
clog		Buffered version of cerr	Screen



p.274

The I/O classes begin with a system of template classes.
a template class defines the form of a class without fully specifying the data upon which it will operate.
Once a template class has been defined, specific instances of it can be created.

The C++ I/O system is built upon two related, but different, template class hierarchies. The first is derived from the low-level I/O class called basic_streambuf. This class supplies the basic, low-level input and output operations and provides the underlying support for the entire C++ I/O system.

The class hierarchy that you will most commonly be working with is derived from basic_ios.
This is a high-level I/O class that provides formatting, error-checking, and status information related to stream I/O.


p.346

Polymorphism is supported by C++ in two ways.
First, it is supported at compile time, through the use of overloaded operators and functions.
Second, it is supported at run time, through the use of virtual functions.

p.347

A pointer declared as a pointer to a base class can also be used to point to any class derived from that base.


base *p;

base base_ob;
derived derived_ob;

p = &baes_ob;

p = &derived_ob;\



a base pointer can point to an object of any class derived from that base without generating a type mismatch error.

Although you can use a base pointer to point to a derived object, you can access only those members of the derived object that were inherited from the base.
This is because the base pointer has knowledge only of the base class. It knows nothing about the members added by the derived class.

And a pointer of the derived type cannot be used to access an object of the base class.


A virtual function is a member function that is declared within a base class and redefined by a derived class. To create a virtual function, precede the function’s declaration with the keyword virtual. When a class containing a virtual function is inherited, the derived class redefines the virtual function relative to the derived class.
In essence, virtual functions implement the “one interface, multiple methods” philosophy that underlies polymorphism. The virtual function within the base class defines the form of the interface to that function. Each redefinition of the virtual function by a derived class implements its operation as it relates specifically to the derived class. That is, the redefinition creates a specific method. When a virtual function is redefined by a derived class, the keyword virtual is not needed.

A virtual function can be called just like any other member function. However, what makes a virtual function interesting-and capable of supporting run-time polymorphism-is what happens when a virtual function is called through a pointer. ~ C++ determines which version of that function will be executed based upon the type of object being pointed to by the pointer. And, this determination is made at run time. Put differently, it is the type of the object pointed to at the time when the call occurs that determines which version of the virtual function will be executed. 

p.351

First, an overloaded function must differ in type and/ or number of parameters, while a redefined virtual function must have precisely the same type and number of parameters and the same return type. (In fact, if you change either the number or type of parameters when redefining a virtual function, it simply becomes an overloaded function and its virtual nature is lost.) Further, virtual functions must be class members. This is not the case for overloaded functions. Also, while destructor functions can be virtual, constructors cannot. Because of the difference between overloaded function and redefined virtual functions, the term overriding is used to describe virtual function redefinition.


20191107



p.352


The key points to understand from the preceding example are that the type of the object being pointed to determines which version of an overridden virtual function will be executed when accessed via a base class pointer, and that this decision is made at run time.

derived에서 base의 virtual function이 오버라이딩 되어있지 않으면 그냥 base function 갖다 씀


20191108



p.358
When there is no meaningful action for a base class virtual function to perform, the implication is that any derived class must override this function.
To ensure that this will occur, C++ supports pure virtual functions.

virtual type func_name(parameter-list) = 0;

When a virtual function is made pure, it forces any derived class to override it.
If a derived class does not, a compile-time error results.

When a class contains at least one pure virtual function, it is referred to as an abstract class. Since an abstract class contains at least one function for which no body exists, it is, technically, an incomplete type, and no objects of that class can be created.
Thus, abstract classes exist only to be inherited.

you can still create a pointer to an abstract class, since it is through the use of base class pointers that run-time polymorphism is achieved.

(it is also permissible to have a reference to an abstract class)



This means that when a derived class inherits a virtual function from a base class and then the derived class is used as a base for yet another derived class, the virtual function can be overridden by the final derived class (as well as the first derived class). 
p.362
Polymorphism is the process by which a common interface is applied to two or more similar(but technically different) situations, thus implementing the “one interface, multiple methods” philosophy.
Polymorphism is important because it can greatly simplify complex systems.

Early binding and Late binding

Early binding essentially refers to those events that can be known at compile time. Specifically, it refers to those function calls that can be resolved during compilation. Early bound entities include “normal” functions, overloaded functions, and nonvirtual member and friend functions.
When these types of functions are compiled, all address information necessary to call them is known at compile time.
The main advantage of early binding is that it is very efficient.
The main disadvantage is lack of flexibility.

Late binding refers to events that must occur at run time. A late bound function call is one in which the address of the function to be called is not known until the program runs.

20191109



p.380
generic class를 쓰면 동일한 메커니즘 / 알고리즘을 쓰는 뭐...연결 리스트라던가, 큐라던가 하는 형태를 type에 상관없이 손쉽게 쓸 수 있음.

template <class Ttype> class class-name { }

Here Ttype is the placeholder type name that will be specified when a class is initiated. If necessary, you can define more than one generic data type by using a comma-seperated list.

Once you have created a generic class, you create a specific instance of that class by using the following general form:

class-name <type> ob;


20191113



One very good use for catch(...) is as the last catch of a cluster of catches.
In this capacity it provides a useful default or “catch all” statement.


#include <iostream>
using namespace std;
 
void Xhandler(int test) throw(int, char, double)
{
 if(test == 0) throw test;
 if(test == 1) throw 'a';
 if(test == 2) throw 123.23;
}
 
int main()
{
 cout << "start" << endl;
 
 try {
   Xhandler(0);
 } catch(int i) {
   cout << "Caught int" << endl;
 } catch(char c) {
   cout << "Caught char" << endl;
 } catch(double d) {
   cout << "Caught double" << endl;
 }
 
 cout << "end";
 
 return 0;
}

In this program, the function Xhandler() can throw only integer, character, and double exceptions.
p.399

As you have learned, you can rethrow an exception. The most likely reason for doing so is to allow multiple handlers access to the exception.
For example, perhaps one exception handler manages one aspect of an exception and a second handler copes with another.
An exception can only be rethrown from within a catch block(or from any function called from within that block). 
When you rethrow an exception, it will not be recaught by the same catch statement.

p.401
Finally, it was decided that a new failure will generate an exception by default, but that a null pointer could be returned instead, as an option.

In standard C++, when an allocation request cannot be honored, new throws a bad-alloc exception. … To have access to this exception, you must include the header <new> in your program.



In Standard C++ it is also possible to have new return null instead of throwing an exception when an allocation failure occurs. This form of new is most useful when you are compiling older code with a modern C++ compiler.

p_var = new(northrow) type;


20191114



p.412
When typeid is applied to a reference to a polymorphic base class, the type returned is that of the actual object being referred to.
The circumstance in which you will most often make use of this feature is when objects are passed to functions by reference.

#include <iostream>
#include <typeinfo>
using namespace std;
 
class BaseClass {
 virtual void f() {};
};
 
class Derived1 : public BaseClass {
 
};
 
class Derived2 : public BaseClass {
 
};
 
void WhatType(BaseClass &ob)
{
 cout << "ob is referencing an object of type ";
 cout << typeid(ob).name() << endl;
}
 
int main()
{
 int i;
 BaseClass baseob;
 Derived1 ob1;
 Derived2 ob2;
 
 WhatType(baseob);
 WhatType(ob1);
 WhatType(ob2);
 
 return 0;
}


Output :::
ob is referencing an object of type 9BaseClass
ob is referencing an object of type 8Derived1
ob is referencing an object of type 8Derived2
Often all you need to know is whether the type of one object matches that of another.
Since the type_info object returned by typeid overloads the == and != operators, this too is easy to accomplish.

#include <iostream>
#include <typeinfo>
using namespace std;
 
class X {
 virtual void f() {}
};
 
class Y {
 virtual void f() {}
};
 
int main()
{
 X x1, x2;
 Y y1;
 
 if(typeid(x1) == typeid(x2))
   cout << "x1 and x2 are some types" << endl;
 else
   cout << "x1 and x2 are different types" << endl;
 
 if(typeid(x1) != typeid(y1)) cout << "x1 and y1 are different types" << endl;
 else cout << "x1 and y1 are same types" << endl;
 
 return 0;
}

p.414

The program defines a simple class hierarchy that draws shapes on the screen.
Since objects are generated randomly, there is no way to know in advance what type of object will be created next.




p.417

The typeid operator can be applied to template classes.




p.420

Although C++ still fully supports the traditional casting operator defined by C, C++ adds four new ones. They are dynamic_cast, const_cast, reinterpret_cast, and static_cast. 
The dynamic_cast operator performs a run-time cast that verifies the validity of a cast.
If, at the time dynamic_cast is executed, the cast is invalid, the cast fails.

dynamic_cast<target-type> (expr)

The target type must be a pointer or reference type, and the expression being cast must evaluate to a pointer or reference.

Thus, dynamic_cast can be used to cast one type of pointer into another or one type of reference into another.

The purpose of dynamic_cast is to perform casts on polymorphic types.
Given the two polymorphic classes B and D, with D derived from B, a dynamic_cast can always cast a D* pointer into an B* pointer. This is because a base pointer can always point to a derived pointer.
But a dynamic_cast can cast a B* pointer into an D* pointer only if the object being pointed to actually is a D object.
// 이게 대체 뭔 뜻이야
D -(inherit)-> B임?
이건 봐야 알겠는데


In general, dynamic_cast will succeed if the pointer(or reference) being cast is a pointer(or reference) to either an object of the target type or an object derived from the target type.
Otherwise, the cast will fail.
If the cast fails, dynamic_cast evaluates to null if the cast involves pointer.
If a dynamic_cast on reference types fails, a bad_cast exception is thrown.


